pragma solidity ^0.5.0;

// First SmartContract will build the basis of the registry.
// unsigned integer of 256 bits: uint

contract SmartCarSharingRegistry {

    event CarSharingContractCreated(uint timestamp, address newCarSharingContractAddress, address sharer, uint8 capacity);
    address[] contracts;

    function createShare(uint8 _capacity) public {

        address newCarSharingContract = address(new SmartCarSharingContract(msg.sender, _capacity));
        contracts.push(newCarSharingContract);
        
        emit CarSharingContractCreated(block.timestamp, newCarSharingContract, msg.sender, _capacity);
    }

    function getShares() external view returns (address[] memory) {
        return contracts;
    }

    function getNumShares() external view returns (uint) {
        return contracts.length;
    }
    
    function getWODScore() external view returns (uint) {
        return WODScore
        
    
    
 
    }

}

// WOD Score = Way of driving score, zusammengefasst aus allen bisherigen Mieten. Wir müssen noch eine Function schreiben, in der der Vermieter bestimmen kann, 
bis zu welchem WOD Score Mieten möglich sind


contract SmartCarSharingContract {

    event RegDriver(uint timestamp, uint DriversLicence); function set(address DriverAddress) public view returns (address) {               // Driver is registered, function sets address
            address public};                                                        
    event CreateWOD(uint timestamp, address DriverAddress, uint WODScore); function set(uint x) public {
            WODScore = x;
    }
    
    
    event RegSharer(uint timestamp, address SharerAddress, uint Vehicle);
    event SharerAccepted(uint timestamp, address SharerAddress, uint Vehicle);
    event CreateVehicle(uint timestamp, address SharerAddress, uint Vehicle; uint WODScore);
    
    event RequestedVehicles(uint timestamp, address DriverAddress, uint WODScore);
    event RequestedBooking(uint timestamp,  address DriverAddress, address SharerAddress, uint Vehicle, uint WODScore);
    event AcceptedBooking(uint timestamp, address DriverAddress, address SharerAddress, uint Vehicle, uint WODScore);
    event SendLocation(uint timestamp, address DriverAddress, address SharerAddress, uint Vehicle, uint VehicleLocation);
    event DepositPayment(uint timestamp, address DriverAddress, address SharerAddress, uint depositAmount);
    
    event StartBooking(uint timestamp, addressDriverAddress, address SharerAddress, uint depositAmount, uint Vehicle);
    event UnlockVehicle(uint timestamp, addressDriverAddress, address SharerAddress, uint Vehicle, uint TCU);
    event EndBooking(uint timestamp, address DriverAddress, address SharerAddress, uint Vehicle, uint TCU);
    event LockVehicle(uint timestamp, addressDriverAddress, address SharerAddress, uint Vehicle, uint TCU);
    event DeterminePayment(uint timestamp, address DriverAddress, address SharerAddress, uint Vehicle, uint TCU, uint WODScoreMultiple; uint WODScoreSingle);
    event DepositRefund (uint timestamp, address DriverAddress, address SharerAddress, uint Vehicle, uint WODScoreMultiple, uint WODScoreSingle, uint PaymentAmount, uint DepositAmount)
    
 
  

    struct Lessee {
        uint rentAmount;
        uint depositAmount;
        bool hasSigned;
        bool hasPaidDeposit;
        uint WODScore;
        bool WODScoreAccepted;
        bool initialized;
        bool TCUfine;
    }

    mapping(address => Lessee) public addressToLessee;
        Lessee[] public lessees;

    address payable public lessorAddress;
    string public writtenContractIpfsHash;

    uint8 public lesseeOccupancy = 0;

    uint deposit;
    uint8 public LESSEE_CAPACITY;

    // inheritance would be an issue with external constructors
    constructor(address payable _landlordAddress, uint8 _capacity) public {
        require(_landlordAddress != address(0), "Landlord address must not be zero!");
        landlordAddress = _landlordAddress;

        TENANT_CAPACITY = _capacity;
    }

    modifier onlyTenant() {
        require(addressToTenant[msg.sender].initialized == true, "Only a tenant can invoke this functionality");
        _;
    }

    modifier onlyLandlord() {
        require(msg.sender == landlordAddress, "Only the landlord can invoke this functionality");
        _;
    }

    modifier isContractProposed() {
        require(!(isSameString(writtenContractIpfsHash, "")), "The written contract has not been proposed yet");
        _;
    }

    modifier hasSigned() {
        require(addressToTenant[msg.sender].hasSigned == true, "Tenant must sign the contract before invoking this functionality");
        _;
    }
    
     modifier notZeroAddres(address addr){
        require(addr != address(0), "0th address is not allowed!");
        _;
    }

    function proposeWrittenContract(string calldata _writtenContractIpfsHash) external onlyLandlord {
        // Update written contract ipfs hash
        writtenContractIpfsHash = _writtenContractIpfsHash;
        emit WrittenContractProposed(block.timestamp, _writtenContractIpfsHash);
    }

    function assignTenant(address _tenantAddress, uint _rentAmount, uint _depositAmount)
        external onlyLandlord isContractProposed notZeroAddres(_tenantAddress){
        // require room in the house
        require(tenantOccupancy < TENANT_CAPACITY, "The rental unit is fully occupied.");
        require(_tenantAddress != landlordAddress, "Landlord is not allowed to be a tenant at the same time.");
        require(addressToTenant[_tenantAddress].initialized == false, "Duplicate tenants are not allowed.");

        tenants.push(Tenant(_rentAmount, _depositAmount, false, false, true));
        addressToTenant[_tenantAddress] = tenants[tenantOccupancy];
        tenantOccupancy++;

        emit TenantAssigned(block.timestamp, _tenantAddress, _rentAmount, _depositAmount);
    }

    function signContract() external onlyTenant isContractProposed {
        require(addressToTenant[msg.sender].hasSigned == false, "The tenant has already signed the contract");

        // Tenant signed
        addressToTenant[msg.sender].hasSigned = true;

        emit TenantSigned(block.timestamp, msg.sender);
    }

    function payDeposit() external payable onlyTenant hasSigned {
        require(msg.value == addressToTenant[msg.sender].depositAmount,
            "Amount of provided deposit does not match the amount of required deposit");

        require(addressToTenant[msg.sender].hasPaidDeposit == false, "The tenant has already paid the deposit");

        deposit += msg.value;
        addressToTenant[msg.sender].hasPaidDeposit = true;

        emit DepositPayed(block.timestamp, msg.sender, msg.value);
    }


  function isSameString(string memory string1, string memory string2) private pure returns (bool) {
    return keccak256(abi.encodePacked(string1)) == keccak256(abi.encodePacked(string2));
  }
}
